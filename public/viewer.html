<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minimal Live Stream - Viewer</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; background: #0b1021; color: #f5f7ff; }
    h1 { margin-bottom: 8px; }
    #videoFrame { width: 100%; max-width: 640px; background: #111827; border-radius: 8px; }
    button { padding: 8px 12px; border: none; border-radius: 6px; background: #4f46e5; color: white; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 8px; align-items: center; }
    .controls label { display: flex; flex-direction: column; font-size: 14px; gap: 4px; }
    .status { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; margin-top: 12px; }
    .status div { background: #111827; padding: 8px; border-radius: 8px; font-size: 14px; }
    .banner { padding: 8px; margin-top: 8px; border-radius: 8px; background: #1e293b; }
    input { padding: 6px; border-radius: 6px; border: 1px solid #1f2937; background: #0f172a; color: #f9fafb; }
  </style>
</head>
<body>
  <h1>Viewer</h1>
  <div class="controls">
    <label>Room ID
      <input id="roomIdInput" type="text" placeholder="room id">
    </label>
    <label>Watch Code
      <input id="watchCodeInput" type="text" placeholder="watch code">
    </label>
    <button id="play">再生開始</button>
    <span id="connection">disconnected</span>
  </div>
  <video id="videoFrame" autoplay playsinline controls></video>
  <div class="status">
    <div>Delay: <span id="delay">-</span> ms</div>
    <div>FPS: <span id="fps">0</span></div>
    <div>Buffer(ms): <span id="buffer">0</span></div>
    <div>Reconnect: <span id="reconnect">0</span></div>
    <div>Viewers: <span id="viewerCount">-</span>/<span id="viewerLimit">-</span></div>
    <div>Room State: <span id="roomState">idle</span></div>
  </div>
  <div class="banner" id="banner"></div>

  <script>
    const videoFrame = document.getElementById("videoFrame");
    const playBtn = document.getElementById("play");
    const connectionEl = document.getElementById("connection");
    const delayEl = document.getElementById("delay");
    const fpsEl = document.getElementById("fps");
    const bufferEl = document.getElementById("buffer");
    const reconnectEl = document.getElementById("reconnect");
    const banner = document.getElementById("banner");
    const roomInput = document.getElementById("roomIdInput");
    const codeInput = document.getElementById("watchCodeInput");
    const viewerCountEl = document.getElementById("viewerCount");
    const viewerLimitEl = document.getElementById("viewerLimit");
    const roomStateEl = document.getElementById("roomState");

    const JSON_HEADER = { "Content-Type": "application/json" };
    const MAX_RECONNECTS = 5;

    let pc = null;
    let statsTimer = null;
    let statusTimer = null;
    let reconnectTimer = null;
    let retries = 0;
    let backoff = 1000;
    let isPlaying = false;
    let viewerId = null;
    let currentRoomId = "";
    let currentWatchCode = "";

    function setBanner(message) {
      banner.textContent = message || "";
    }

    function updateConnectionState(state) {
      connectionEl.textContent = state;
    }

    function resetIndicators() {
      delayEl.textContent = "-";
      fpsEl.textContent = "0";
      bufferEl.textContent = "0";
      reconnectEl.textContent = "0";
      viewerCountEl.textContent = "-";
      viewerLimitEl.textContent = "-";
      roomStateEl.textContent = "idle";
    }

    async function fetchRoomStatus(roomId) {
      if (!roomId) {
        throw new Error("room_id_required");
      }
      const response = await fetch(`/api/room/${roomId}/status`);
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        throw new Error(payload.error || "status_error");
      }
      return payload;
    }

    async function pollRoomStatus() {
      if (!currentRoomId) return;
      try {
        const status = await fetchRoomStatus(currentRoomId);
        viewerCountEl.textContent = status.viewerCount ?? "-";
        viewerLimitEl.textContent = status.limits?.viewerLimit ?? "-";
        roomStateEl.textContent = status.state || "-";
        if (status.limits?.full) {
          setBanner("満員です");
          scheduleReconnect("満員のため再接続を停止します");
        } else {
          setBanner("");
        }
      } catch (error) {
        console.warn("room status poll failed", error);
      }
    }

    function startStatusTimer() {
      stopStatusTimer();
      statusTimer = setInterval(pollRoomStatus, 5000);
    }

    function stopStatusTimer() {
      if (statusTimer) {
        clearInterval(statusTimer);
        statusTimer = null;
      }
    }

    function stopStatsTimer() {
      if (statsTimer) {
        clearInterval(statsTimer);
        statsTimer = null;
      }
    }

    function startStatsTimer() {
      stopStatsTimer();
      statsTimer = setInterval(() => {
        if (!pc) return;
        pc.getStats().then((reports) => {
          reports.forEach((report) => {
            if (report.type === "inbound-rtp" && report.kind === "video") {
              const rttMs = report.roundTripTime ? Math.round(report.roundTripTime * 1000) : "-";
              const jitter = report.jitter ? Math.round(report.jitter * 1000) : "0";
              delayEl.textContent = typeof rttMs === "number" ? rttMs : "-";
              bufferEl.textContent = jitter;
              fpsEl.textContent = (report.framesDecoded || 0).toString();
              const loss = report.packetsLost || 0;
              const received = report.packetsReceived || 0;
              const total = received + loss;
              const lossRatio = total ? loss / total : 0;
              let label = "Normal";
              if (lossRatio > 0.05 || (typeof rttMs === "number" && rttMs > 400)) {
                label = "Bad";
              } else if (lossRatio > 0.02 || (typeof rttMs === "number" && rttMs > 250)) {
                label = "Weak";
              } else if (lossRatio < 0.005 && typeof rttMs === "number" && rttMs < 120) {
                label = "Strong";
              }
              updateConnectionState(label);
            }
          });
        });
      }, 2000);
    }

    function cleanupPeer() {
      if (pc) {
        pc.close();
        pc = null;
      }
    }

    async function leaveRoom() {
      if (!currentRoomId || !viewerId) return;
      await fetch(`/api/room/${currentRoomId}/viewer/leave`, {
        method: "POST",
        headers: JSON_HEADER,
        body: JSON.stringify({ viewerId }),
      }).catch(() => {});
      viewerId = null;
    }

    async function waitIce() {
      if (!pc) return;
      if (pc.iceGatheringState === "complete") return;
      await new Promise((resolve) => {
        const handler = () => {
          if (pc.iceGatheringState === "complete") {
            pc.removeEventListener("icegatheringstatechange", handler);
            resolve();
          }
        };
        pc.addEventListener("icegatheringstatechange", handler);
      });
    }

    function handlePCState() {
      if (!pc) return;
      const state = pc.connectionState;
      if (state === "failed" || state === "disconnected") {
        scheduleReconnect("接続が切断されました");
      }
    }

    async function connectRoom() {
      const status = await fetchRoomStatus(currentRoomId);
      viewerCountEl.textContent = status.viewerCount ?? "-";
      viewerLimitEl.textContent = status.limits?.viewerLimit ?? "-";
      roomStateEl.textContent = status.state || "-";
      if (status.state !== "live") {
        throw new Error("ライブが開始されていません");
      }
      if (status.limits?.full) {
        throw new Error("満員です");
      }
      if (status.watchCodeRequired && !currentWatchCode) {
        throw new Error("視聴コードを入力してください");
      }
      cleanupPeer();
      pc = new RTCPeerConnection();
      pc.addEventListener("connectionstatechange", handlePCState);
      pc.addEventListener("track", (event) => {
        const [stream] = event.streams;
        if (stream) {
          videoFrame.srcObject = stream;
        }
      });
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await waitIce();
      const response = await fetch(`/api/room/${currentRoomId}/subscribe/offer`, {
        method: "POST",
        headers: JSON_HEADER,
        body: JSON.stringify({
          offer: pc.localDescription?.sdp,
          watchCode: currentWatchCode,
          viewerId,
        }),
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        throw new Error(payload.error || "subscribe_failed");
      }
      if (!payload.viewerAnswer?.sdp) {
        throw new Error("無効な回答");
      }
      await pc.setRemoteDescription({
        type: payload.viewerAnswer.type || "answer",
        sdp: payload.viewerAnswer.sdp,
      });
      viewerId = payload.viewerId || viewerId;
      updateConnectionState("connected");
      startStatsTimer();
      startStatusTimer();
      setBanner("");
    }

    async function attemptConnect() {
      try {
        await leaveRoom();
        await connectRoom();
        retries = 0;
        reconnectEl.textContent = retries;
        backoff = 1000;
      } catch (error) {
        console.warn("connect failed", error);
        scheduleReconnect(error.message || "接続に失敗しました");
      }
    }

    function scheduleReconnect(message) {
      if (!isPlaying) return;
      setBanner(message);
      updateConnectionState("retrying");
      retries += 1;
      reconnectEl.textContent = retries;
      if (retries > MAX_RECONNECTS) {
        setBanner("再接続上限に達しました");
        stopViewing();
        return;
      }
      cleanupPeer();
      stopStatsTimer();
      stopStatusTimer();
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
      }
      reconnectTimer = setTimeout(() => {
        reconnectTimer = null;
        attemptConnect();
      }, Math.min(backoff, 30000));
      backoff = Math.min(backoff * 2, 30000);
    }

    function stopViewing() {
      isPlaying = false;
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      cleanupPeer();
      stopStatsTimer();
      stopStatusTimer();
      leaveRoom();
      updateConnectionState("disconnected");
      resetIndicators();
      setBanner("視聴を停止しました");
      playBtn.disabled = false;
    }

    function startViewing() {
      if (isPlaying) return;
      currentRoomId = roomInput.value.trim();
      currentWatchCode = codeInput.value.trim();
      if (!currentRoomId) {
        setBanner("Room IDを入力してください");
        return;
      }
      isPlaying = true;
      retries = 0;
      reconnectEl.textContent = retries;
      playBtn.disabled = true;
      updateConnectionState("connecting");
      attemptConnect();
    }

    playBtn.addEventListener("click", startViewing);
    window.addEventListener("beforeunload", stopViewing);
  </script>
</body>
</html>
