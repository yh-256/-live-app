<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minimal Live Stream - Broadcaster</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; background: #0b1021; color: #f5f7ff; }
    h1 { margin-bottom: 8px; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px; }
    .controls label { display: flex; flex-direction: column; font-size: 14px; gap: 4px; }
    button { padding: 8px 12px; border: none; border-radius: 6px; background: #4f46e5; color: white; cursor: pointer; }
    button.secondary { background: #1f2937; color: #e5e7eb; }
    button.danger { background: #dc2626; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .status { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; margin-top: 12px; }
    .status div { background: #111827; padding: 8px; border-radius: 8px; font-size: 14px; }
    .room-info { margin-top: 12px; display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 8px; }
    .room-info div { background: #111827; padding: 8px; border-radius: 8px; font-size: 14px; }
    .room-info a { color: #60a5fa; word-break: break-all; }
    #preview { width: 100%; max-width: 480px; background: #1f2937; border-radius: 8px; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; background: #111827; }
  </style>
</head>
<body>
  <h1>Broadcaster</h1>
  <div class="controls">
    <label>配信キー
      <input id="key" type="password" value="SECRET" style="padding:6px;border-radius:6px;border:1px solid #1f2937;background:#0f172a;color:#f9fafb;">
    </label>
    <label>解像度
      <select id="resolution" style="padding:6px;border-radius:6px;border:1px solid #1f2937;background:#0f172a;color:#f9fafb;">
        <option value="low">Low (320x240)</option>
        <option value="medium" selected>Medium (640x480)</option>
        <option value="high">High (1280x720)</option>
      </select>
    </label>
    <label>カメラ
      <select id="camera" style="padding:6px;border-radius:6px;border:1px solid #1f2937;background:#0f172a;color:#f9fafb;">
        <option value="user">Front</option>
        <option value="environment">Back</option>
      </select>
    </label>
    <label>マイク
      <button id="micToggle" type="button" class="secondary">Mic: ON</button>
    </label>
    <label>配信
      <div style="display:flex; gap:8px;">
        <button id="start">Start</button>
        <button id="stop" class="danger" disabled>Stop</button>
      </div>
    </label>
  </div>
  <video id="preview" autoplay playsinline muted></video>
  <div class="status">
    <div>RTT: <span id="rtt">-</span> ms</div>
    <div>FPS: <span id="fps">0</span></div>
    <div>Quality: <span id="quality" class="badge">-</span></div>
    <div>Buffered: <span id="buffered">0</span> ms</div>
    <div>State: <span id="state">idle</span></div>
    <div>Connection: <span id="connection" class="badge">-</span></div>
    <div>Viewers: <span id="viewerCount">0</span>/<span id="viewerLimit">0</span></div>
  </div>
  <div class="room-info">
    <div>Room ID: <span id="roomIdDisplay">-</span></div>
    <div>Watch Code: <span id="watchCodeDisplay">-</span></div>
    <div>Watch URL: <a id="watchUrlDisplay" href="#" target="_blank" rel="noreferrer">-</a></div>
  </div>
  <div class="banner" id="statusBanner"></div>

  <script>
    const preview = document.getElementById('preview');
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const micToggleBtn = document.getElementById('micToggle');
    const resolutionSelect = document.getElementById('resolution');
    const cameraSelect = document.getElementById('camera');
    const keyInput = document.getElementById('key');
    const rttEl = document.getElementById('rtt');
    const fpsEl = document.getElementById('fps');
    const qualityEl = document.getElementById('quality');
    const bufferedEl = document.getElementById('buffered');
    const stateEl = document.getElementById('state');
    const connectionEl = document.getElementById('connection');
    const viewerCountEl = document.getElementById('viewerCount');
    const viewerLimitEl = document.getElementById('viewerLimit');
    const roomIdEl = document.getElementById('roomIdDisplay');
    const watchCodeEl = document.getElementById('watchCodeDisplay');
    const watchUrlEl = document.getElementById('watchUrlDisplay');
    const statusBanner = document.getElementById('statusBanner');

    const JSON_HEADER = { "Content-Type": "application/json" };
    const QUALITY_PROFILES = {
      low: { label: "Low", videoBitrate: 500, audioBitrate: 48, fps: 10 },
      medium: { label: "Medium", videoBitrate: 900, audioBitrate: 64, fps: 15 },
      high: { label: "High", videoBitrate: 1600, audioBitrate: 96, fps: 24 },
    };
    const RESOLUTIONS = {
      low: { width: 640, height: 360 },
      medium: { width: 960, height: 540 },
      high: { width: 1280, height: 720 },
    };

    let pc = null;
    let localStream = null;
    let roomDetails = null;
    let statsInterval = null;
    let statusInterval = null;
    let isStreaming = false;
    let lastVideoStats = null;

    function setBanner(message) {
      statusBanner.textContent = message || "";
    }

    function updateStatus(partial) {
      if (partial.rtt !== undefined) rttEl.textContent = partial.rtt;
      if (partial.fps !== undefined) fpsEl.textContent = partial.fps;
      if (partial.quality !== undefined) qualityEl.textContent = partial.quality;
      if (partial.buffered !== undefined) bufferedEl.textContent = partial.buffered;
      if (partial.state !== undefined) stateEl.textContent = partial.state;
      if (partial.connection !== undefined) connectionEl.textContent = partial.connection;
      if (partial.viewerCount !== undefined) viewerCountEl.textContent = partial.viewerCount;
      if (partial.viewerLimit !== undefined) viewerLimitEl.textContent = partial.viewerLimit;
    }

    function qualityProfile() {
      return QUALITY_PROFILES[resolutionSelect.value] || QUALITY_PROFILES.medium;
    }

    resolutionSelect.addEventListener("change", () => {
      qualityEl.textContent = `${qualityProfile().label} (${resolutionSelect.value})`;
    });

    async function setupMedia() {
      const resolution = RESOLUTIONS[resolutionSelect.value] || RESOLUTIONS.medium;
      const facingMode = cameraSelect.value === "environment" ? "environment" : "user";
      localStream = await navigator.mediaDevices.getUserMedia({
        video: { width: resolution.width, height: resolution.height, facingMode },
        audio: true,
      });
      preview.srcObject = localStream;
      await preview.play().catch(() => {});
    }

    function stopLocalStream() {
      if (!localStream) return;
      localStream.getTracks().forEach((track) => track.stop());
      preview.srcObject = null;
      localStream = null;
    }

    function createPeerConnection() {
      const connection = new RTCPeerConnection();
      connection.addEventListener("iceconnectionstatechange", () => {
        const state = connection.iceConnectionState;
        if (state === "failed" || state === "disconnected") {
          setBanner("ICE connection lost");
        }
      });
      return connection;
    }

    function stopPeerConnection() {
      if (!pc) return;
      pc.getSenders().forEach((sender) => {
        sender.track?.stop();
      });
      pc.close();
      pc = null;
      lastVideoStats = null;
    }

    async function waitForIceGathering() {
      if (!pc) return;
      if (pc.iceGatheringState === "complete") return;
      await new Promise((resolve) => {
        const handler = () => {
          if (pc.iceGatheringState === "complete") {
            pc.removeEventListener("icegatheringstatechange", handler);
            resolve();
          }
        };
        pc.addEventListener("icegatheringstatechange", handler);
      });
    }

    async function createRoom() {
      const payload = {
        viewerLimit: 10,
        key: keyInput.value.trim(),
      };
      const response = await fetch("/api/room/create", {
        method: "POST",
        headers: JSON_HEADER,
        body: JSON.stringify(payload),
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok) {
        throw new Error(data.error || "room_creation_failed");
      }
      roomDetails = data;
      roomIdEl.textContent = data.roomId || "-";
      watchCodeEl.textContent = data.watchCode || "-";
      if (data.watchUrl) {
        watchUrlEl.textContent = data.watchUrl;
        watchUrlEl.href = data.watchUrl;
      } else {
        watchUrlEl.textContent = "-";
        watchUrlEl.removeAttribute("href");
      }
      updateStatus({
        viewerCount: data.viewerCount ?? 0,
        viewerLimit: data.limits?.viewerLimit ?? "-",
        state: data.state || "idle",
      });
    }

    async function postPublish(offer) {
      const profile = qualityProfile();
      const response = await fetch(`/api/room/${roomDetails.roomId}/publish/offer`, {
        method: "POST",
        headers: JSON_HEADER,
        body: JSON.stringify({
          offer,
          tracks: [
            { trackName: "video", kind: "video", bitrate: profile.videoBitrate },
            { trackName: "audio", kind: "audio", bitrate: profile.audioBitrate },
          ],
          key: keyInput.value.trim(),
        }),
      });
      const payload = await response.json().catch(() => ({}));
      if (!response.ok) {
        throw new Error(payload.error || "publish_failed");
      }
      return payload;
    }

    async function startPublishing() {
      pc = createPeerConnection();
      localStream.getTracks().forEach((track) => pc.addTrack(track, localStream));
      updateStatus({ state: "connecting" });
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await waitForIceGathering();
      const payload = await postPublish(pc.localDescription.sdp);
      if (!payload?.publisherAnswer?.sdp) {
        throw new Error("invalid_answer");
      }
      await pc.setRemoteDescription({
        type: payload.publisherAnswer.type || "answer",
        sdp: payload.publisherAnswer.sdp,
      });
      updateStatus({ state: "streaming" });
    }

    function startStatsPolling() {
      stopStatsPolling();
      statsInterval = setInterval(() => {
        if (!pc) return;
        pc.getStats().then((stats) => {
          stats.forEach((report) => {
            if (report.type === "outbound-rtp" && report.kind === "video") {
              const rttMs = report.roundTripTime ? Math.round(report.roundTripTime * 1000) : "-";
              const jitterMs = report.jitter ? Math.round(report.jitter * 1000) : "-";
              let fpsValue = "-";
              if (lastVideoStats) {
                const deltaFrames = (report.framesEncoded || 0) - (lastVideoStats.framesEncoded || 0);
                const deltaTime = report.timestamp - lastVideoStats.timestamp || 1;
                fpsValue =
                  deltaFrames && deltaTime ? ((deltaFrames / deltaTime) * 1000).toFixed(1) : "-";
              }
              lastVideoStats = report;
              const loss = report.packetsLost || 0;
              const sent = report.packetsSent || 0;
              const lossRatio = sent ? loss / sent : 0;
              const connectionLabel =
                lossRatio > 0.05 || (typeof rttMs === "number" && rttMs > 400)
                  ? "Bad"
                  : lossRatio > 0.02 || (typeof rttMs === "number" && rttMs > 250)
                    ? "Weak"
                    : lossRatio < 0.005 && typeof rttMs === "number" && rttMs < 120
                      ? "Strong"
                      : "Normal";
              updateStatus({
                rtt: typeof rttMs === "number" ? rttMs : "-",
                fps: fpsValue,
                buffered: jitterMs,
                connection: connectionLabel,
                quality: `${qualityProfile().label} (${resolutionSelect.value})`,
              });
            }
          });
        });
      }, 2000);
    }

    function stopStatsPolling() {
      if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
      }
    }

    function startStatusPolling() {
      stopStatusPolling();
      statusInterval = setInterval(refreshRoomStatus, 5000);
    }

    function stopStatusPolling() {
      if (statusInterval) {
        clearInterval(statusInterval);
        statusInterval = null;
      }
    }

    async function refreshRoomStatus() {
      if (!roomDetails?.roomId) return;
      const response = await fetch(`/api/room/${roomDetails.roomId}/status`);
      if (!response.ok) return;
      const data = await response.json().catch(() => ({}));
      updateStatus({
        viewerCount: data.viewerCount ?? 0,
        viewerLimit: data.limits?.viewerLimit ?? "-",
      });
      if (data.limits?.full) {
        setBanner("Viewer limit reached");
      } else {
        setBanner("");
      }
    }

    async function endRoom() {
      if (!roomDetails?.roomId) return;
      await fetch(`/api/room/${roomDetails.roomId}/end`, {
        method: "POST",
        headers: JSON_HEADER,
      }).catch(() => {});
    }

    async function startStreaming() {
      if (isStreaming) return;
      setBanner("");
      startBtn.disabled = true;
      stopBtn.disabled = true;
      micToggleBtn.disabled = true;
      resolutionSelect.disabled = true;
      cameraSelect.disabled = true;
      keyInput.disabled = true;
      try {
        await setupMedia();
        await createRoom();
        await startPublishing();
        isStreaming = true;
        stopBtn.disabled = false;
        micToggleBtn.disabled = false;
        startStatsPolling();
        startStatusPolling();
        qualityEl.textContent = `${qualityProfile().label} (${resolutionSelect.value})`;
      } catch (error) {
        console.error(error);
        setBanner(error.message || "Failed to start broadcast");
        stopStreaming();
      }
    }

    async function stopStreaming() {
      stopStatsPolling();
      stopStatusPolling();
      stopPeerConnection();
      stopLocalStream();
      await endRoom();
      isStreaming = false;
      startBtn.disabled = false;
      stopBtn.disabled = true;
      micToggleBtn.disabled = true;
      resolutionSelect.disabled = false;
      cameraSelect.disabled = false;
      keyInput.disabled = false;
      micToggleBtn.textContent = 'Mic: ON';
      updateStatus({
        state: "idle",
        rtt: "-",
        fps: "-",
        buffered: "0",
        connection: "-",
        viewerCount: 0,
        viewerLimit: "-",
        quality: "-",
      });
      roomDetails = null;
      roomIdEl.textContent = "-";
      watchCodeEl.textContent = "-";
      watchUrlEl.textContent = "-";
      watchUrlEl.removeAttribute("href");
      setBanner("");
    }

    micToggleBtn.addEventListener("click", () => {
      if (!localStream) return;
      const audioTrack = localStream.getAudioTracks()[0];
      if (!audioTrack) return;
      audioTrack.enabled = !audioTrack.enabled;
      micToggleBtn.textContent = `Mic: ${audioTrack.enabled ? "ON" : "OFF"}`;
    });

    startBtn.addEventListener("click", startStreaming);
    stopBtn.addEventListener("click", stopStreaming);
    window.addEventListener("beforeunload", stopStreaming);
  </script>
</body>
</html>
