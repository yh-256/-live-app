<!doctype html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Minimal Live Stream - Broadcaster</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; background: #0b1021; color: #f5f7ff; }
    h1 { margin-bottom: 8px; }
    .controls { display: flex; flex-wrap: wrap; gap: 12px; margin-bottom: 12px; }
    .controls label { display: flex; flex-direction: column; font-size: 14px; gap: 4px; }
    button { padding: 8px 12px; border: none; border-radius: 6px; background: #4f46e5; color: white; cursor: pointer; }
    button.secondary { background: #1f2937; color: #e5e7eb; }
    button.danger { background: #dc2626; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .status { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 8px; margin-top: 12px; }
    .status div { background: #111827; padding: 8px; border-radius: 8px; font-size: 14px; }
    #preview { width: 100%; max-width: 480px; background: #1f2937; border-radius: 8px; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; background: #111827; }
  </style>
</head>
<body>
  <h1>Broadcaster</h1>
  <div class="controls">
    <label>配信キー
      <input id="key" type="password" value="SECRET" style="padding:6px;border-radius:6px;border:1px solid #1f2937;background:#0f172a;color:#f9fafb;">
    </label>
    <label>解像度
      <select id="resolution" style="padding:6px;border-radius:6px;border:1px solid #1f2937;background:#0f172a;color:#f9fafb;">
        <option value="low">Low (320x240)</option>
        <option value="medium" selected>Medium (640x480)</option>
        <option value="high">High (1280x720)</option>
      </select>
    </label>
    <label>カメラ
      <select id="camera" style="padding:6px;border-radius:6px;border:1px solid #1f2937;background:#0f172a;color:#f9fafb;">
        <option value="user">Front</option>
        <option value="environment">Back</option>
      </select>
    </label>
    <label>マイク
      <button id="micToggle" type="button" class="secondary">Mic: ON</button>
    </label>
    <label>配信
      <div style="display:flex; gap:8px;">
        <button id="start">Start</button>
        <button id="stop" class="danger" disabled>Stop</button>
      </div>
    </label>
  </div>
  <video id="preview" autoplay playsinline muted></video>
  <canvas id="canvas" width="640" height="480" hidden></canvas>
  <div class="status">
    <div>RTT: <span id="rtt">-</span> ms</div>
    <div>FPS: <span id="fps">0</span></div>
    <div>Quality: <span id="quality" class="badge">-</span></div>
    <div>Buffered: <span id="buffered">0</span> KB</div>
    <div>State: <span id="state">idle</span></div>
  </div>

  <script>
    const preview = document.getElementById('preview');
    const canvas = document.getElementById('canvas');
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const micToggleBtn = document.getElementById('micToggle');
    const resolutionSelect = document.getElementById('resolution');
    const cameraSelect = document.getElementById('camera');
    const keyInput = document.getElementById('key');
    const rttEl = document.getElementById('rtt');
    const fpsEl = document.getElementById('fps');
    const qualityEl = document.getElementById('quality');
    const bufferedEl = document.getElementById('buffered');
    const stateEl = document.getElementById('state');

    const resolutions = {
      low: { width: 320, height: 240 },
      medium: { width: 640, height: 480 },
      high: { width: 1280, height: 720 },
    };

    const qualitySteps = [
      { label: 'High', jpegQuality: 0.8, fps: 10, resolution: 'high' },
      { label: 'Medium', jpegQuality: 0.6, fps: 7, resolution: 'medium' },
      { label: 'Low', jpegQuality: 0.4, fps: 5, resolution: 'low' },
    ];

    let ws = null;
    let mediaStream = null;
    let mediaRecorder = null;
    let sending = false;
    let frameTimes = [];
    let qualityIndex = 0;
    let downgradeAt = 0;
    let stableSince = 0;
    let rafId = null;
    let lastPingTs = 0;
    let lastPongTs = 0;
    let pingTimer = null;

    function logStatus(message) {
      console.log('[broadcaster]', message);
    }

    function updateStatus(partial) {
      if (partial.rtt !== undefined) rttEl.textContent = partial.rtt;
      if (partial.fps !== undefined) fpsEl.textContent = partial.fps.toFixed(1);
      if (partial.quality !== undefined) qualityEl.textContent = partial.quality;
      if (partial.buffered !== undefined) bufferedEl.textContent = partial.buffered;
      if (partial.state !== undefined) stateEl.textContent = partial.state;
    }

    function currentQuality() {
      return qualitySteps[qualityIndex];
    }

    function computeWsUrl() {
      const proto = location.protocol === 'https:' ? 'wss' : 'ws';
      return `${proto}://${location.host}/ws?role=broadcaster&key=${encodeURIComponent(keyInput.value.trim())}`;
    }

    function applyCanvasResolution() {
      const res = resolutions[resolutionSelect.value];
      if (res) {
        canvas.width = res.width;
        canvas.height = res.height;
      }
    }

    async function setupMedia() {
      const res = resolutions[resolutionSelect.value];
      const facingMode = cameraSelect.value === 'environment' ? { exact: 'environment' } : 'user';
      const constraints = {
        video: { width: res.width, height: res.height, facingMode },
        audio: true,
      };
      mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
      preview.srcObject = mediaStream;
      await preview.play();
      applyCanvasResolution();
    }

    function stopTracks() {
      if (mediaStream) {
        mediaStream.getTracks().forEach((t) => t.stop());
        mediaStream = null;
      }
    }

    function detachMediaRecorder() {
      if (mediaRecorder) {
        try { mediaRecorder.stop(); } catch (e) {}
        mediaRecorder = null;
      }
    }

    function base64FromBlob(blob) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => {
          const dataUrl = reader.result;
          const base64 = dataUrl.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    }

    function sendAudio() {
      if (!mediaStream) return;
      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });
      mediaRecorder.ondataavailable = async (event) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const base64 = await base64FromBlob(event.data);
        if (base64.length > 300000) return;
        const payload = { type: 'audio', ts: Date.now(), data: base64 };
        ws.send(JSON.stringify(payload));
      };
      mediaRecorder.start(500);
    }

    function effectiveFps(now) {
      frameTimes.push(now);
      const cutoff = now - 3000;
      frameTimes = frameTimes.filter((t) => t >= cutoff);
      return frameTimes.length / 3;
    }

    function attemptDowngrade(reason) {
      if (Date.now() - downgradeAt < 5000) return;
      const q = qualityIndex;
      const resOrder = ['high', 'medium', 'low'];
      if (qualityIndex < qualitySteps.length - 1) {
        qualityIndex += 1;
        logStatus(`Quality down: ${reason}`);
      } else {
        const currentResIndex = resOrder.indexOf(resolutionSelect.value);
        if (currentResIndex < resOrder.length - 1) {
          resolutionSelect.value = resOrder[currentResIndex + 1];
          logStatus(`Resolution down: ${reason}`);
          applyCanvasResolution();
        }
      }
      downgradeAt = Date.now();
      stableSince = 0;
    }

    function attemptUpgrade() {
      if (!stableSince || Date.now() - stableSince < 30000) return;
      const resOrder = ['low', 'medium', 'high'];
      const currentResIndex = resOrder.indexOf(resolutionSelect.value);
      if (qualityIndex > 0) {
        qualityIndex -= 1;
        logStatus('Quality up');
      } else if (currentResIndex < resOrder.length - 1) {
        resolutionSelect.value = resOrder[currentResIndex + 1];
        logStatus('Resolution up');
        applyCanvasResolution();
      }
      stableSince = Date.now();
    }

    function drawLoop() {
      if (!sending || !ws || ws.readyState !== WebSocket.OPEN || !mediaStream) return;
      const quality = currentQuality();
      const now = performance.now();
      const fpsNow = effectiveFps(now);
      const ctx = canvas.getContext('2d');
      ctx.drawImage(preview, 0, 0, canvas.width, canvas.height);
      const dataUrl = canvas.toDataURL('image/jpeg', quality.jpegQuality);
      if (dataUrl.length < 900000) {
        const payload = { type: 'video', ts: Date.now(), data: dataUrl };
        ws.send(JSON.stringify(payload));
      }
      updateStatus({
        fps: fpsNow,
        quality: `${quality.label} (${resolutionSelect.value})`,
        buffered: Math.round(ws.bufferedAmount / 1024),
      });

      const buf = ws.bufferedAmount;
      const nowTs = Date.now();
      if (buf > 500000 || fpsNow < quality.fps - 2 || (lastPongTs && nowTs - lastPongTs > 15000)) {
        attemptDowngrade('congestion');
      } else if (buf < 200000 && fpsNow >= quality.fps - 1) {
        if (!stableSince) stableSince = Date.now();
        attemptUpgrade();
      }

      const frameInterval = 1000 / quality.fps;
      rafId = setTimeout(() => requestAnimationFrame(drawLoop), frameInterval);
    }

    function setupPing() {
      pingTimer = setInterval(() => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const now = Date.now();
        if (lastPingTs && lastPongTs < lastPingTs && now - lastPingTs > 30000) {
          logStatus('pong timeout, closing connection');
          ws.close(4000, 'pong timeout');
          return;
        }
        lastPingTs = now;
        ws.send(JSON.stringify({ type: 'ping', ts: now }));
      }, 5000);
      return pingTimer;
    }

    function handleWs() {
      const url = computeWsUrl();
      ws = new WebSocket(url);
      ws.addEventListener('open', () => {
        sending = true;
        stateEl.textContent = 'streaming';
        drawLoop();
      });
      ws.addEventListener('message', (event) => {
        try {
          const msg = JSON.parse(event.data);
          if (msg.type === 'pong' && typeof msg.ts === 'number') {
            lastPongTs = Date.now();
            const rtt = lastPongTs - msg.ts;
            updateStatus({ rtt });
          }
        } catch (e) {}
      });
      ws.addEventListener('close', () => {
        sending = false;
        stateEl.textContent = 'closed';
        if (pingTimer) clearInterval(pingTimer);
      });
      ws.addEventListener('error', () => {
        sending = false;
        stateEl.textContent = 'error';
        if (pingTimer) clearInterval(pingTimer);
      });
      return ws;
    }

    async function startStreaming() {
      if (sending) return;
      startBtn.disabled = true;
      resolutionSelect.disabled = true;
      cameraSelect.disabled = true;
      keyInput.disabled = true;
      try {
        await setupMedia();
        const socket = handleWs();
        sendAudio();
        setupPing();
        micToggleBtn.disabled = false;
        stopBtn.disabled = false;
      } catch (e) {
        console.error(e);
        stopStreaming();
      }
    }

    function stopStreaming() {
      sending = false;
      if (rafId) cancelAnimationFrame(rafId);
      detachMediaRecorder();
      stopTracks();
      if (ws) {
        ws.close();
        ws = null;
      }
      if (pingTimer) {
        clearInterval(pingTimer);
        pingTimer = null;
      }
      startBtn.disabled = false;
      resolutionSelect.disabled = false;
      cameraSelect.disabled = false;
      keyInput.disabled = false;
      micToggleBtn.disabled = true;
      stopBtn.disabled = true;
      frameTimes = [];
      updateStatus({ state: 'idle', fps: 0, buffered: 0, rtt: '-', quality: '-' });
    }

    startBtn.addEventListener('click', startStreaming);
    stopBtn.addEventListener('click', stopStreaming);

    micToggleBtn.addEventListener('click', () => {
      if (!mediaStream) return;
      const audioTrack = mediaStream.getAudioTracks()[0];
      if (!audioTrack) return;
      audioTrack.enabled = !audioTrack.enabled;
      micToggleBtn.textContent = `Mic: ${audioTrack.enabled ? 'ON' : 'OFF'}`;
    });

    window.addEventListener('beforeunload', stopStreaming);
  </script>
</body>
</html>
